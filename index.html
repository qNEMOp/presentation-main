<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Численные методы</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/beige.css" id="theme">
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin="" />
		<link rel="shortcut icon" href="https://atom.io/favicon.ico">

		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

		<style>
			.my-input {
			color: rgb(139, 97, 43);
			width: 100px;
			height: 40px;
			border: 2px solid transparent;
			border-radius: 8px
			}
			.my-input:hover {
				background: #b8b097;
			}

			.my-input:focus {
				outline: none;
				box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(241, 8, 8, 0.19);
}
			input {
				width:20%;
				margin:10px 0;
				padding:10px;
			}
			.type-2 {
				background-color: #fafafa;
				border:0;
				box-shadow:0 0 4px rgba(0,0,0,0.3);
				transition: .3s box-shadow;
			}
			.type-2:hover {
				box-shadow:0 0 4px rgba(0,0,0,0.5);
			}
			select {
				font-size: 30px;
			}
			#table {
				font-size: 50%;
			}
			.hide {
				display: none;
			}
			.map {
				height: 350px;
			}
		</style>
	</head>
	<body>
		<div class="reveal">

			<button name="nubex" value="Nubex">
				<img style="position: fixed; z-index: 30; font-size: 22px;
				left: 60px; bottom: 5px;" id="noteswitch" src="https://img.icons8.com/windows/32/000000/browse-folder.png" alt="" />
				</button>
			
			<div class="slides">

			<section class="center" data-markdown  data-separator-notes="^Note:">
				<script type="text/template">
					Численные методы
					=========================
			
					

					Note:
					Заголовок
				</script>
			</section>
			<section class="center" data-markdown  data-separator-notes="^Note:">
				<script type="text/template">
					
					### Определение численных методов

					Note:
					Определение численных методов
				</script>
			</section>
			<section data-markdown  data-separator-notes="^Note:">
				<script type="text/template">
					### Определение

					Численные методы (вычислительные методы, методы вычислений) — раздел вычислительной математики, изучающий приближенные способы решения типовых математических задач,
					 которые либо не решаются, либо трудно решаются точными аналитическими методами (вычислительная математика в узком смысле).
				
					Note:
					Определение
				</script>
			</section>
			<section data-markdown  data-separator-notes="^Note:">
				<script type="text/template">
					#### Основами для вычислительных методов являются:

					- решение систем линейных уравнений;
					- интерполирование и приближённое вычисление функций;
					- численное интегрирование;
					- численное решение системы нелинейных уравнений;
					- численное решение обыкновенных дифференциальных уравнений;
					- уравнений математической физики;
					- решение задач оптимизации.
				
					Note:
					Основами для вычислительных методов являются:
					-	решение систем линейных уравнений;
					-	интерполирование и приближённое вычисление функций;
					-	численное интегрирование;
					-	численное решение системы нелинейных уравнений;
					-	численное решение обыкновенных дифференциальных уравнений;
					-	численное решение уравнений в частных производных (уравнений математической физики);
					-	решение задач оптимизации.
				</script>
			</section>
			<section data-markdown  data-separator-notes="^Note:">
				<script type="text/template">
					
					#### Система линейных алгебраических уравнений (СЛАУ)
					— система уравнений, каждое уравнение в которой является линейным — алгебраическим уравнением первой степени.
					Note:
					СЛАУ
				</script>
			</section>
			<section data-markdown  data-separator-notes="^Note:">
				<script type="text/template">
					#### Система линейных алгебраических уравнений (СЛАУ)
					В классическом варианте коэффициенты при переменных, свободные члены и неизвестные считаются вещественными числами, но все методы и результаты сохраняются 
					(либо естественным образом обобщаются) на случай любых полей, например, комплексных чисел.
					
					Note:
					СЛАУ
				</script>
			</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Общий вид СЛАУ:
						
						
						$ \begin{cases}
							a_{11}x_1+a_{12}+\ldots+a_{1n}x_n=b_1\\\\ 
							a_{21}x_1+a_{22}+\ldots+a_{2n}x_n=b_2\\\\
							\dots \\\\
							a_{m1}x_1+a_{m2}+\ldots+a_{mn}x_n=b_m
					\end{cases} $ \
					Здесь $m$ — количество уравнений \
					 $n$ — количество переменных \
					 $x_{1},x_{2},\dots ,x_{n}$ — неизвестные \
					  $a_{11},a_{12},\dots ,a_{mn}$ и $b_{1},b_{2},\dots ,b_{m}$ — предполагаются известными.
						Note:
						Общий вид СЛАУ представляет собой m - уравнений с n - неизвестными
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						Пусть исходная система выглядит следующим образом:
						$$ \begin{cases}
							a_{11}x_1+\ldots+a_{1n}x_n=b_1 \\\\ 
							\dots \\\\
							a_{m1}x_1+\ldots+a_{mn}x_n=b_m
							\end{cases} $$
						Её можно записать в матричном виде: $Ax=b$
					
						Note:
						Исходная система из m - уравнений с n - неизвестными
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						$$A=\begin{pmatrix}
					a_{11} \ldots a_{1n} \\\\
					\dots \\\\
					a_{m1} \ldots a_{mn}
			 		\end{pmatrix},$$
					 $	x=\begin{pmatrix}
						x_{1} \\\\
						\dots \\\\
						x_{n}
						 \end{pmatrix}$,
					 $b=\begin{pmatrix}
						 a_{1} \\\\
						 \dots \\\\
						 a_{n} 
						\end{pmatrix}$
					
						Note:
					Матрица коэфициентов А размерностью m на n \
							х - вектор из n - элементов \
							b - столбец свободных членов 
							
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						
						Алгоритм метода Гаусса состоит из двух этапов. Первый этап называется прямым ходом метода и заключается в приведении матрицы системы к треугольному виду 
						по формулам:\
						 $k=1,2,\ldots,n-1$ \
						$a_{ij}=a_{ij}-\dfrac{a_{ik}}{a_{kk}}a_{kj} \kern{15px}  j=k,k+1,\ldots,n$ \
						$$b_{i}=b_{i}-\dfrac{a_{ik}}{a_{kk}}b_{k} \kern{15px} i=k+1,k+2,\ldots,n$$
						
						Note:
						Алгоритм метода Гаусса состоит из двух этапов. Первый этап называется прямым ходом метода и заключается в приведении матрицы системы к треугольному виду 
						по формулам: \
						Из i-ого j-ого элемента вычитается i-ый k-ый умноженный на k-ый j-ый и деленный на k диагональный элемент
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
					
						Таким образом, выполнив $n-1$ шаг, мы получим систему с верхней
						треугольной матрицей, причем эта система эквивалентна исходной,
						а элемент $a_{kk}$, на который происходит деление, называется ведущим
						элементом на $k$-м шаге. 
						
						Note:
						Треугольная матрица
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						Решение системы с треугольной матрицей
						выписывается явно и называется обратным ходом метода Гаусса:
						$$ x_{k}=\dfrac{b_k-\displaystyle\sum_{j=k+1}^na_{kj}x_j}{a_{kk}},\kern{15px} k=n,n-1,\ldots,1$$
						
						Note:
						Неизвестные находятся как разность свободного члена и суммы произведения свободного члена на предыдущий неизвестный элемент, деленная на ведущий элемент
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						#### Пример
						Покажем, как методом Гаусса можно решить следующую систему:
						$$ \begin{cases}
							2x+y-z=8 \\\\
							-3x-y+2z=11\\\\
							-2x+y+z=-3
						\end{cases} $$

						Note:
						Пример решения методом Гаусса \
						Дана система из трёх уравнений с тремя неизвестными
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						#### Пример
						Обнулим коэффициенты при $x$ во второй и третьей строчках. Для этого прибавим к ним первую строчку, умноженную на $\textstyle \frac {3}{2} $и $1$, соответственно:
						$$ \begin{cases}
							2x+y-z=8 \\\\
							\frac {1}{2}y+\frac {1}{2}z=1\\\\ 
							2y+z=-5
							\end{cases} 
						$$
						
						Note:
						Обнуляем нижний треугольник, для этого обнуляем коэффициенты при $х$ во второй и третьей строчках.
						Для этого прибавим к ним первую строчку, умноженную на $\textstyle \frac {3}{2} $и $1$, соответственно
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						#### Пример
						Теперь обнулим коэффициент при $y$ в третьей строке, вычтя из неё вторую строку, умноженную на 4:
						$$ \begin{cases}
							2x+y-z=8 \\\\ 
							\frac{1}{2}y+\frac {1}{2}z=1 \\\\
							-z=1
							\end{cases} 
						$$
						
						Note:
						Далее обнуляем коэффициент при $y$ в третьей строке, вычтя из неё вторую строку, умноженную на 4
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса
						#### Пример
						В результате мы привели исходную систему к треугольному виду, тем самым закончив первый этап алгоритма.
						На втором этапе разрешим полученные уравнения в обратном порядке. Имеем:
						$z=-1$ из третьего; \
						$y=3$ из второго, подставив полученное $z$; \
						$x=2$ из первого, подставив полученные $z$ и $y$.\
						Таким образом исходная система решена.
						
						Note:
						Решаем в обратном направлении. $z$ - известна, подставляем во 2 сторчку и находим $y$, после этого подставляем всё в первую строчку и находим $x$
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Жордана-Гаусса
						
						Этот метод отличается от обычного метода Гаусса тем, что на каждом шаге прямого
						хода, после нахождения ведущего элемента, зануляются элементы
						столбца не только ниже ведущего элемента, но и выше, то есть матрица $A$ приводится к диагональному виду.

						Note:
						Метод Жордана-Гаусса
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Жордана-Гаусса
						
						Тогда решение записывается как $x_i=\frac {b_i}{a_{ii}}$, где $i=1,2,\ldots,n$. \
						Если еще на каждом шаге перед
						занулением других элементов столбца ведущую строку делить на ведущий элемент, то в результате прямого хода получится единичная
						матрица. А значит, обратный ход не потребуется, так как на месте
						столбца правой части получим решение исходной системы.
						
						
						Note:
						Так как матрица приводится к диагональному виду, то неизвестные находятся как частное свободного члена на ведущий элемент
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						Метод Якоби — разновидность метода простой итерации для решения системы линейных алгебраических уравнений. Назван в честь Карла Густава Якоби. 
						
						Note:
						Метод Якоби
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						Для того, чтобы построить итеративную процедуру метода Якоби, необходимо провести предварительное преобразование системы уравнений 
						$Ax=b$ к итерационному виду \
						$x=Bx+g$. Оно может быть осуществлено по одному из следующих правил:

						Note:
						Приведение системы $Ax=b$ к итерационному виду $x=Bx+g$
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						
						$$B=E-D^{-1}A=D^{-1}(D-A)$$
						$$B=-D^{-1}(L+U)=-D^{-1}(A-D)$$
						$$g=D^{-1}b$$
						$$D_{ii}^{-1}=\frac {1}{D^{-1}},\kern{20px} D_{ii}\ne 0,\kern{20px} i=1,2,\ldots,n$$

						Note:
						Матрица $B$ находится как 
						1) разность единичной матрицы и произведения обратной диагональной матрицы на исходную матрицу, что равно произведению обратной диагональной матрицы на разность диагональной матрицы и исходной \
						2) произведение обратной диагональной матрицы со знаком минус на сумму $L$ и $U$, что равно произведение обратной диагональной матрицы со знаком минус на разность исходной матрицы и диагональной \
						где $L$ и $U$ содержат верхнюю и нижнюю треугольные части исходной матрицы $A$ \
						Элемент $g$ равен произведению обратной диагональной матрицы со знаком минус на столбец свободных членов
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						$D$ означает матрицу, у которой на главной диагонали стоят соответствующие элементы матрицы $A$, а все остальные нули; 
						тогда как матрицы $U$ и $L$ содержат верхнюю и нижнюю треугольные части $A$, на главной диагонали которых нули. $E$ - еденичная матрица. 

						Note:
						Обозначения 
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						Тогда процедура нахождения решения имеет вид: \
						$x^{(k+1)}=Bx^{(k)}+g$ \
						Или в виде поэлементной формулы:\
						$x_i^{(k+1)}=\frac {1}{a_{ii}}(b_i-\sum_{i\ne j} a_{ij}x_j^{(k)}) $ \
						$i=1,2,\ldots,n$\
						где $k$ счётчик итерации.

						Note:
						Поэлементно находим решение \
						Из свободного члена вычитаем сумму произведения коэффициентов матрицы A и х из предыдущей итерации по всем $i$ не равным $j$ от 1 до n и делим полученную разность на соответсвующий диагональный элемент
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						#### Условие остановки
						Условие окончания итерационного процесса при достижении точности $\varepsilon$  имеет вид:\
						$\Vert x^{(k+1)}-x^{(k)} \rVert \geqslant \frac {1-q}{q}\varepsilon$\
						Для достаточно хорошо обусловленной матрицы $B$ (при $\Vert B \rVert = q < \frac {1}{2}$) оно выполняется при\
						$\Vert x^{(k+1)}-x^{(k)} \rVert \geqslant \varepsilon$\
						Данный критерий не требует вычисления нормы матрицы и часто используется на практике.

						Note:
						Для остановки итерационного процесса точности $\varepsilon$ необходимо выполнение уравнения: нормированная разность следующего решения и нынешнего больше или равна $\frac {1-q}{q}\varepsilon$, где q равна норме В, \
						если норма В меньше 0.5, то достаточно, чтобы норма следующего решения и нынешнего была больше или равна $\varepsilon$
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						При этом точное условие окончания итерационного процесса имеет вид\
						$$\Vert Ax^{(k)}-b \rVert \geqslant \varepsilon$$
						и требует дополнительного умножения матрицы на вектор на каждой итерации, что примерно в два раза увеличивает вычислительную сложность алгоритма.

						Note:
						Норма разноси произведения исходной матрицы А на решение х и столбца свободных членов меньше или равна $\varepsilon$ будет точным условием окончания итерационного процесса
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби
						Достаточное условие сходимости интерационных методов (метода Якоби) - преобладание диагональных элементов

						Note:
						Достаточное условие сходимости
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Невязка
						Невязка — величина ошибки (расхождения) приближённого равенства.

						Note:
						Определение
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Невязка
						Пусть требуется найти такое x, что значение функции: $f(x)=b$.
						Подставив приближенное значение $x_0$ вместо $x$, получаем невязку \
						$b-f(x_0)$, 
						а ошибка в этом случае равна $x_0-x$
						Если точное значение $x$ неизвестно, вычисление ошибки невозможно, однако при этом может быть определена невязка.

						Note:
						Пояснение
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Невязка аппроксимации функции
						
						Схожее название используется в дифференциальных, интегральных и функциональных уравнениях.
						Для аппроксимации $f_a$ решения $f$ уравнения $T(f)(x)=g(x)$,\
						невязка может быть функцией \
						$g(x)-T(f_a)(x)$ 
						
						Note:
						Невязка аппроксимации функции
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Невязка аппроксимации функции
						Или по-другому максимумом нормы разности
						$\max_{x \in \chi}|g(x)-T(f_a)(x)|$ \
						на области $\chi$, где функция
						$f_a$ есть усреднённое решение $f$, или некоторый интеграл функции разности, например,\
						$\int_{\chi}|g(x)-T(f_a)(x)|^2dx$
						
						Note:
						Невязка аппроксимации функции
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Невязка аппроксимации функции
						
						В большинстве случаев, чем меньше невязка, тем аппроксимированное значение ближе к решению, то есть, \
						$\frac{f_a(x)-f(x)}{f(x)}\ll 1$. \
						В этом случае начальное уравнение принималось за корректное; и невязка могла быть использована как показатель отклонения аппроксимации от точного решения.

						Note:
						Чем меньше невязка, тем аппроксимированное значение ближе к решению
					</script>
				</section>

				<section>
					<h2>Решение СЛАУ методом Гаусса</h2>
					<input type="text"  id="size" class=type-2 placeholder="Введите размерность матрицы">
					<!-- Кнопка запуска программы -->
					<input type="button" value="Клик" id="_size" class=my-input>
					<!-- Вывод системы -->
					<br>
					<output id="system"></output>
					<!-- Вывод результата -->
					<br>
					<output id="_result"></output>
					<aside class="notes">
						Решение СЛАУ методом Гаусса <br>
						Для решения системы уравнений:<br>
						1) введите количество уравнений и нажмите на кнопку "Клик" <br>
						2) далее всплывет окно, показывающие номер уравнения (подтверждаем) <br>
						3) введите коэфициенты неизвестных по порядку (если неизвестные пропущены, то ставим $0$), в том числе свободные члены <br>
						4) после ввода уравнения, появится окно с подтверждением ввода следующего уравнения (смотри пункт 3) <br>
						5) Ваша система уравнений появится на экране, ниже появится решение
					</aside>
				</section>

				<section>
					<h2>Решение СЛАУ методом Жордана-Гаусса</h2>
					<input type="text" class=type-2 id="size1" placeholder="Введите размерность матрицы">
					<!-- Кнопка запуска программы -->
					<input type="button" value="Клик" id="_size1" class=my-input>
					<!-- Вывод системы -->
					<br>
					<output id="system1"></output>
					<!-- Вывод результата -->
					<br>
					<output id="_result1"></output>
					<aside class="notes">
						Решение СЛАУ методом Жордана-Гаусса<br>
						Для решения системы уравнений:<br>
						1) введите количество уравнений и нажмите на кнопку "Клик" <br>
						2) далее всплывет окно, показывающие номер уравнения (подтверждаем) <br>
						3) введите коэфициенты неизвестных по порядку (если неизвестные пропущены, то ставим $0$), в том числе свободные члены <br>
						4) после ввода уравнения, появится окно с подтверждением ввода следующего уравнения (смотри пункт 3) <br>
						5) Ваша система уравнений появится на экране, ниже появится решение
					</aside>
				</section>

				<section>
					<h2>Решение СЛАУ методом Якоби</h2>
					<input type="text" class=type-2 id="size2" placeholder="Введите размерность матрицы">
					<!-- Кнопка запуска программы -->
					<input type="button" value="Клик" id="_size2" class=my-input>
					<!-- Вывод системы -->
					<br>
					<output id="system2"></output>
					<!-- Вывод результата -->
					<br>
					<output id="_result2"></output>
					<aside class="notes">
						Решение СЛАУ методом Якоби<br>
						Для решения системы уравнений:<br>
						1) введите количество уравнений и нажмите на кнопку "Клик", после чего заполните матрицу коэфициентов <br>
						2) всплывет окно, показывающие номер строки (подтверждаем) <br>
						3) введите коэфициенты неизвестных <br>
						4) после ввода коэфициентов появится окно с подтверждением ввода следующей строки (смотри пункт 3) <br>
						5) после заполнения матрица подтвердите заполнение столбца свободных членов и заполните его<br>
						6) Ваша система уравнений появится на экране, ниже появится решение
					</aside>
				</section>
				
				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						 # Исходный код программ

						Note:
						Исходный код программ
					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Гаусса

						```
						document.querySelector('#_size').onclick = (e) => {
							n=document.querySelector('#size').value; //Задаем количсетво уравнений
							var m=new Array(n); //Определение рабочего массива
							var l=new Array(n); //Массив ответов
							var i, j, k;        //Вспомогательные переменные
							for(i = 0; i < n; ++i) { //Создаем двумерные массивы
									m[i] = new Array(n);
									l[i] = new Array(n);
							}
							
							for(i = 0; i < n; ++i) { //Заполнение системы уравнений
								alert("Введите"+" "+(i+1)+" " +"уравнение")
									for(j=0; j <= n; ++j) {
											m[i][j] = prompt("Введите коэффициенты:");
									}
							}
							
							//Выводим систему уравнений
							let sys="\\begin{cases}";
							for(i = 0; i < n; ++i) {
								for(j = 0; j <= n; ++j) {
									if(j==n){
										sys+="="+m[i][j];
									}
									else if(j==0){
										sys+=m[i][j]+"x_{"+(j+1)+"}";
									}
									else {sys+="+"+m[i][j]+"x_{"+(j+1)+"}"};
								}	
								if (i < n-1) {
									sys+="\\\\"
								}
							}
							sys+="\\end{cases}"
							document.querySelector('#system').innerHTML = katex.renderToString(sys);
							
							Iteration(n); //Вызываем функцию обнуления нижнего треугольника
							Answers(); //Вызываем функцию перемены строк
			
							function Iteration(iter_item) { //Функция итеррация
								for(iter_item=0;iter_item<(n-1);iter_item++) { //Цикл выполнения итерраций
									if (m[iter_item][iter_item] == 0) SwapRows(iter_item); //Проверка на ноль
									for(j=n; j>=iter_item; j--) {
										m[iter_item][j] /= m[iter_item][iter_item]; //Делим строку i на а[i][i]
									}
									for(i=iter_item+1; i < n; i++) { //Выполнение операций со строками
										for(j=n;j>=iter_item;j--) {
											m[i][j] -= m[iter_item][j] * m[i][iter_item];
										}
									}	
								}
							};
							function SwapRows(iter_item) { //Функция перемены строк
								for(i=iter_item+1; i < n; i++) {
									if(m[i][iter_item] !== 0) {
										for(j=0;j<=n;j++) {
											k = m[i-1][j];
											m[i-1][j] = m[i][j];
											m[i][j] = k;
										}
									} 
								}
							};
							
							function Answers() { //Функция поиска и вывода корней
								let x="\\begin{cases}";
									l[n-1] = m[n-1][n]/m[n-1][n-1];
									for(i=n-2;i>=0;i--) {
										k=0;
										for(j=n-1;j>i;j--) {
											k = (m[i][j]*l[j]) + k;
										}
										l[i] = m[i][n] - k;
									}
									for(i=n;i>0;i--) {
									x+="x_{" + i + "}"+" = " + l[i-1];
									x+="\\\\"
									}
									x+="\\end{cases}";
									document.querySelector('#_result').innerHTML = katex.renderToString(x);
							};
							//document.querySelector('#_result').innerHTML = katex.renderToString(x);
							//Скрываем саму кнопку
							document.querySelector('#_size').style.display = 'none';
							document.querySelector('#size').style.display = 'none';
						```
						Note: Исходный код метода Гаусса
					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Жордана-Гаусса

						```
						document.querySelector('#_size1').onclick = (e) => {
							n=document.querySelector('#size1').value; //Задаем количсетво уравнений
							var m=new Array(n); //Определение рабочего массива
							var i, j, k,x1;        //Вспомогательные переменные
							for(i=0; i < n; ++i) { //Создаем двумерный массив
								m[i] = new Array(n+1);
							}
							
							for(i=0; i < n; ++i) { //Заполнение системы уравнений
								alert("Введите"+" "+(i+1)+" " +"уравнение")
								for(j=0; j <= n; ++j) {
									m[i][j] = prompt("Введите коэффициенты:");
								}
							}
			
							//Выводим систему уравнений
							let sys="\\begin{cases}";
							for(i=0; i < n; ++i) {
								for(j=0; j <= n; ++j) {
									if(j==n){
										sys+="="+m[i][j];
									}
									else if(j==0){
										sys+=m[i][j]+"x_{"+(j+1)+"}";
									}
									else {sys+="+"+m[i][j]+"x_{"+(j+1)+"}"};
								}	
								if (i < n-1) {
									sys+="\\\\"
								}
							}
							sys+="\\end{cases}"
							document.querySelector('#system1').innerHTML = katex.renderToString(sys);
			
							Iteration(n); //Вызываем функцию обнуления нижнего треугольника
							ObrIteration(n); //Вызываем функцию обнуления верхнего треугольника
			
							//Обнуление нижнего треугольника
							function Iteration(iter_item) { //Функция итеррация
								for(iter_item=0;iter_item<(n-1);iter_item++) { //Цикл выполнения итерраций
									if (m[iter_item][iter_item] == 0) SwapRows(iter_item); //Проверка на ноль
									for(j=n; j>=iter_item; j--) {
										m[iter_item][j] /= m[iter_item][iter_item]; //Делим строку i на а[i][i]
									}
									for(i=iter_item+1; i < n; i++) { //Выполнение операций со строками
										for(j=n;j>=iter_item;j--) {
											m[i][j] -= m[iter_item][j] * m[i][iter_item];
										}
									}		
								}
							};
							function SwapRows(iter_item) { //Функция перемены строк
								for(i=iter_item+1;i < n;i++) {
									if(m[i][iter_item] !== 0) {
										for(j=0;j<=n;j++) {
											k = m[i-1][j];
											m[i-1][j] = m[i][j];
											m[i][j] = k;
										}
									} 
								}
							};
							//Обнуление верхнего треугольника
							function ObrIteration(iter_item) { //Функция итеррация
								for(iter_item=n-1;iter_item >= 1;iter_item--) { //Цикл выполнения итерраций
									for(i=iter_item-1; i>=0; i--) { //Выполнение операций со строками
										for(j=n;j>=iter_item;j--) {
											m[i][j] = m[i][j] - (m[iter_item][j] * m[i][iter_item])/m[iter_item][iter_item];
										}
									}	
								}
							};
							//Вывод решения
							let x ="\\begin{cases}";
							for(i=0; i < n; i++) { //Выполнение операций со строками
								x1=m[i][n]/m[i][i]
									x+="x_{" + (i+1) +"}" + " = " + x1;
									x+="\\\\"
							}
							x+="\\end{cases}"
							document.querySelector('#_result1').innerHTML = katex.renderToString(x);
						}
						```
						Note: Исходный код метода Жордана-Гаусса
					</script>
				</section>
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Метод Якоби

						```
						document.querySelector('#_size2').onclick = (e) => {
							n=document.querySelector('#size2').value; //задаем размерность матрицы
							var m=new Array(n); //Определение рабочего массива
							var b=new Array(n), x=new Array(n),x1=new Array(n), Norm=1,l=0;
							var c1=new Array(n),c2=new Array(n); //создаем массивы для сумм 
							for(i = 0; i < n; ++i) {//создаем двумерный массив
									m[i] = new Array(n);
							}
							for(i=0; i< n; ++i) { //Заполнение матрицы 
								alert("Введите коэфициенты"+" "+ (i+1)+" " +"строки ")
									for(j=0; j < n; ++j) {
											m[i][j] = prompt("Введите коэффициенты неизвестных:");
									}
							}
							alert("Введите коэффициенты свободных членов:")
							for(i=0; i< n; i++) { //Заполнение столбца свободных членов
								b[i]=prompt("Введите коэффициенты свободных членов:");
							}
							
							//вывод исходной системы уравнений
							let sys="\\begin{cases}";
							for(i=0; i< n; ++i) {
								for(j=0; j < n; ++j) {
									if(j==0){
										sys+=m[i][j]+"x_{"+(j+1)+"}";
									}
									else {sys+="+"+m[i][j]+"x_{"+(j+1)+"}"};
								}	
								sys+="="+b[i];
								if (i < n-1) {
									sys+="\\\\"
								}
							}
							sys+="\\end{cases}"
							document.querySelector('#system2').innerHTML = katex.renderToString(sys);
			
							for(i=0;i< n;i++){  //цикл заполнения начального приближения
								x[i]=0.5;
							}
							while(Norm>0.01){ //условие остановки заданной точности
								Norm=0; //обнуление нормы
								
								for(i=0;i< n;i++){ 
									x1[i]=x[i]; //запоминаем предыдущее решение
									c1[i]=0; //обнуление суммы нижнего треугольника
									c2[i]=0; //обнуление суммы верхнего треугольника
								}
								for(k=0; k< n; ++k) {
									for(i=0; i <= (k-1); i++) {
										c1[i]+=m[k][i]*x[i] //сумма нижнего треугольника
									}
								}
								for(k=0; k< n; k++) {
										for(i=k+1; i < n; ++i) {
											c2[i]+=m[k][i]*x[i] // сумма верхнего треугольника
										}
								}
								for(k=0; k< n; k++) { 
									x[k]=(b[k]-c1[k]-c2[k])/m[k][k]; //нахождение решения
								}
								
								for(i=0;i< n;i++){
									Norm+=Math.pow(x[i]-x1[i],2); //нахождение нормы разности предыдущего решения и нового
								}
								l++
								if(l>2000){ //выход из цикла в случае бесконечности
									break;
								}
							}
							let x2="";
							//проверка на правильность введенных данных
							if(l>2000) //если данные введены не правильно то выводим ошибку
							{
								x2+="\\text{Не выполнено достаточное условие сходимости -}";
								x2+="\\\\"
								x2+="\\text{ преобладание диагональных элементов}";
							}
							else{ // иначе выводим решение
							x2 += "\\begin{cases}"
							for(i=0;i< n;i++){ 
								x2+="x_{" + (i+1) +"}"+ " = " + x[i];
								x2+="\\\\";
							}
							x2+="\\end{cases}"
							}
							//вывод решения на экран
							document.querySelector('#_result2').innerHTML = katex.renderToString(x2);
						```
						Note: Исходный код метода Якоби
					</script>
				</section>
				<section data-menu-title="Фото">
					<img src="image/1.jpg" alt="Фото">
					<aside class="notes">Шрэк фоткает</aside>
				</section>	
				<section data-menu-title="К Бэйл">
					<img src="image/2.jpg" alt="К Бэйл">
					<aside class="notes">Матрица, Кристиан Бэйл, описание</aside>
				</section>
				<section data-menu-title="Понял?">
					<img src="image/3.jpg" alt="Понял?">
					<aside class="notes">Аудитория, слушающая лекцию</aside>
				</section>
				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						 ## Спасибо за внимание

						Note:
						Конец
					</script>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>

		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
		<script src="js/algebrite.bundle-for-browser.js"></script>
		<script src="js/math.js"></script>
		<script src="js/plotly-2.6.3.min.js"></script>
		<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
		<script src="http://city.9pr.ru/socket.io/socket.io.js"></script>
		
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				center: false,

				slideNumber: true,

				controls: true, 

				dependencies: [
					{
						src: 'plugin/menu/menu.js'
					},
				],

				menu : {
					numbers: true,
					markers: true, 
				},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
			});
		</script>

		<!--
		<script>
			document.querySelector('#_size2').onclick = (e) => {
				N=document.querySelector('#size2').value;
				var A=new Array(N); //Определение рабочего массива
				var F=new Array(N), TempX = Array(N), norm, X = new Array(N), eps=0.1,x2; 
				for(i=0; i<N; ++i) {
						A[i] = new Array(N);
				}
				for(i=0; i<N; ++i) { //Заполнение матрицы 
					alert("Введите уравнение")
						for(j=0; j < N; ++j) {
								A[i][j] = prompt("Введите коэффициенты неизвестных:");
						}
				}
				for(i=0; i<N; i++) {
					F[i]=prompt("Введите коэффициенты свободных членов:");
				}
				for(i=0;i<N;i++){
					X[i]=1;
				}
				do {
					for (i = 0; i < N; i++) {
						TempX[i] = F[i];
						for (g = 0; g < N; g++) {
							if (i != g)
								TempX[i] -= A[i][g] * X[g];
						}
						TempX[i] /= A[i][i];
					}
							norm = Math.abs(X[0] - TempX[0]);
					for (h = 0; h < N; h++) {
						if (Math.abs(X[h] - TempX[h]) > norm)
							norm = Math.abs(X[h] - TempX[h]);
						X[h] = TempX[h];
					}
				} while (norm > eps);
				for(i=0;i<N;i++){
					TempX[i]=0;
				}
				for(i=0;i<N;i++){
					x2+="<center> x" + (i+1) + " = " + X[i] + "</center>";
				}
				document.querySelector('#_result2').innerHTML = x2+norm;
			}
		</script>
	-->

		<script>

			//Функция для включения и выключения заметок слайда
			let showNodes = () => {
				Reveal.configure({
					//Навесим событие на клавишу D
					//Покажим заметки
					showNotes: (
						Reveal.getConfig().showNotes ? 
							false: true
						)
				});
				return false;
			}

			//Открываем заметки или по кнопке или по клавише D
			document.querySelector('#noteswitch').onclick = showNodes;
				Reveal.configure({
					keyboard: {
						68: showNodes
					}
				});
				
			
				document.querySelector('#_size2').onclick = (e) => {
				n=document.querySelector('#size2').value; //задаем размерность матрицы
				var m=new Array(n); //Определение рабочего массива
				var b=new Array(n), x=new Array(n),x1=new Array(n), Norm=1,l=0; //Вспомогательные переменные
				var c1=new Array(n),c2=new Array(n); //создаем массивы для сумм 
				for(i=0; i<n; ++i) {//создаем двумерный массив
						m[i] = new Array(n);
				}
				for(i=0; i<n; ++i) { //Заполнение матрицы 
					alert("Введите коэфициенты"+" "+ (i+1)+" " +"строки ")
						for(j=0; j < n; ++j) {
								m[i][j] = prompt("Введите коэффициенты неизвестных:");
						}
				}
				alert("Введите коэффициенты свободных членов:")
				for(i=0; i<n; i++) { //Заполнение столбца свободных членов
					b[i]=prompt("Введите коэффициенты свободных членов:");
				}
				
				//вывод исходной системы уравнений
				let sys="\\begin{cases}";
				for(i=0; i<n; ++i) {
					for(j=0; j < n; ++j) {
						if(j==0){
							sys+=m[i][j]+"x_{"+(j+1)+"}";
						}
						else {sys+="+"+m[i][j]+"x_{"+(j+1)+"}"};
					}	
					sys+="="+b[i];
					if (i < n-1) {
						sys+="\\\\"
					}
				}
				sys+="\\end{cases}"
				document.querySelector('#system2').innerHTML = katex.renderToString(sys);

				for(i=0;i<n;i++){  //цикл заполнения начального приближения
					x[i]=0.5;
				}
				while(Norm>0.01){ //условие остановки заданной точности
					Norm=0; //обнуление нормы
					
					for(i=0;i<n;i++){ 
						x1[i]=x[i]; //запоминаем предыдущее решение
						c1[i]=0; //обнуление суммы нижнего треугольника
						c2[i]=0; //обнуление суммы верхнего треугольника
					}
					for(k=0; k<n; ++k) {
							for(i=0; i <= (k-1); i++) {
								c1[i]+=m[k][i]*x[i] //сумма нижнего треугольника
							}
					}
					for(k=0; k<n; k++) {
							for(i=k+1; i < n; ++i) {
								c2[i]+=m[k][i]*x[i] // сумма верхнего треугольника
							}
					}
					for(k=0; k<n; k++) { 
						x[k]=(b[k]-c1[k]-c2[k])/m[k][k]; //нахождение решения
					}
					
					for(i=0;i<n;i++){
						Norm+=Math.pow(x[i]-x1[i],2); //нахождение нормы разности предыдущего решения и нового
					}
					l++
					if(l>2000){ //выход из цикла в случае бесконечности
						break;
					}
				}
				let x2="";
				//проверка на правильность введенных данных
				if(l>2000) //если данные введены не правильно то выводим ошибку
				{
					x2+="\\text{Не выполнено достаточное условие сходимости -}";
					x2+="\\\\"
					x2+="\\text{ преобладание диагональных элементов}";
				}
				else{ // иначе выводим решение
				x2 += "\\begin{cases}"
				for(i=0;i<n;i++){ 
					x2+="x_{" + (i+1) +"}"+ " = " + x[i];
					x2+="\\\\";
				}
				x2+="\\end{cases}"
				}
				//вывод решения на экран
				document.querySelector('#_result2').innerHTML = katex.renderToString(x2);
			}
			
		</script>
		
		<script>
			document.querySelector('#_size').onclick = (e) => {
				n=document.querySelector('#size').value; //Задаем количсетво уравнений
				var m=new Array(n); //Определение рабочего массива
				var l=new Array(n); //Массив ответов
				var i, j, k;        //Вспомогательные переменные
				for(i=0; i<n; ++i) { //Создаем двумерные массивы
						m[i] = new Array(n);
						l[i] = new Array(n);
				}
				
				for(i=0; i<n; ++i) { //Заполнение системы уравнений
					alert("Введите"+" "+(i+1)+" " +"уравнение")
						for(j=0; j <= n; ++j) {
								m[i][j] = prompt("Введите коэффициенты:");
						}
				}
				
				//Выводим систему уравнений
				let sys="\\begin{cases}";
				for(i=0; i<n; ++i) {
					for(j=0; j <= n; ++j) {
						if(j==n){
							sys+="="+m[i][j];
						}
						else if(j==0){
							sys+=m[i][j]+"x_{"+(j+1)+"}";
						}
						else {sys+="+"+m[i][j]+"x_{"+(j+1)+"}"};
					}	
					if (i < n-1) {
						sys+="\\\\"
					}
				}
				sys+="\\end{cases}"
				document.querySelector('#system').innerHTML = katex.renderToString(sys);
				
				Iteration(n); //Вызываем функцию обнуления нижнего треугольника
				Answers(); //Вызываем перемены строк

				function Iteration(iter_item) { //Функция итеррация
						for(iter_item=0;iter_item<(n-1);iter_item++) { //Цикл выполнения итерраций
								if (m[iter_item][iter_item] == 0) SwapRows(iter_item); //Проверка на ноль
								for(j=n; j>=iter_item; j--) {
										m[iter_item][j] /= m[iter_item][iter_item]; //Делим строку i на а[i][i]
								}
								for(i=iter_item+1; i<n; i++) { //Выполнение операций со строками
										for(j=n;j>=iter_item;j--) {
												m[i][j] -= m[iter_item][j] * m[i][iter_item];
										}
								}
								
						}
				};
				function SwapRows(iter_item) { //Функция перемены строк
						for(i=iter_item+1;i<n;i++) {
								if(m[i][iter_item] !== 0) {
										for(j=0;j<=n;j++) {
												k = m[i-1][j];
												m[i-1][j] = m[i][j];
												m[i][j] = k;
										}
								} 
						}
				};
				
				function Answers() { //Функция поиска и вывода корней
					let x="\\begin{cases}";
						l[n-1] = m[n-1][n]/m[n-1][n-1];
						for(i=n-2;i>=0;i--) {
								k=0;
								for(j=n-1;j>i;j--) {
										k = (m[i][j]*l[j]) + k;
								}
								l[i] = m[i][n] - k;
						}
						for(i=n;i>0;i--) {
						x+="x_{" + i + "}"+" = " + l[i-1];
						x+="\\\\"
						}
						x+="\\end{cases}";
						document.querySelector('#_result').innerHTML = katex.renderToString(x);
				};
				//document.querySelector('#_result').innerHTML = katex.renderToString(x);
				//Скрываем саму кнопку
				document.querySelector('#_size').style.display = 'none';
				document.querySelector('#size').style.display = 'none';
			}
		</script>

		<script>
			document.querySelector('#_size1').onclick = (e) => {
				n=document.querySelector('#size1').value; //Задаем количсетво уравнений
				var m=new Array(n); //Определение рабочего массива
				var i, j, k,x1;        //Вспомогательные переменные
				for(i=0; i<n; ++i) { //Создаем двумерный массив
						m[i] = new Array(n+1);
				}
				
				for(i=0; i<n; ++i) { //Заполнение системы уравнений
					alert("Введите"+" "+(i+1)+" " +"уравнение")
						for(j=0; j <= n; ++j) {
								m[i][j] = prompt("Введите коэффициенты:");
						}
				}

				//Выводим систему уравнений
				let sys="\\begin{cases}";
				for(i=0; i<n; ++i) {
					for(j=0; j <= n; ++j) {
						if(j==n){
							sys+="="+m[i][j];
						}
						else if(j==0){
							sys+=m[i][j]+"x_{"+(j+1)+"}";
						}
						else {sys+="+"+m[i][j]+"x_{"+(j+1)+"}"};
					}	
					if (i < n-1) {
						sys+="\\\\"
					}
				}
				sys+="\\end{cases}"
				document.querySelector('#system1').innerHTML = katex.renderToString(sys);

				Iteration(n); //Вызываем функцию обнуления нижнего треугольника
				ObrIteration(n); //Вызываем функцию обнуления верхнего треугольника

				//Обнуление нижнего треугольника
				function Iteration(iter_item) { //Функция итеррация
						for(iter_item=0;iter_item<(n-1);iter_item++) { //Цикл выполнения итерраций
							if (m[iter_item][iter_item] == 0) SwapRows(iter_item); //Проверка на ноль
								for(j=n; j>=iter_item; j--) {
										m[iter_item][j] /= m[iter_item][iter_item]; //Делим строку i на а[i][i]
								}
								for(i=iter_item+1; i<n; i++) { //Выполнение операций со строками
										for(j=n;j>=iter_item;j--) {
												m[i][j] -= m[iter_item][j] * m[i][iter_item];
										}
								}
								
						}
					};
					function SwapRows(iter_item) { //Функция перемены строк
						for(i=iter_item+1;i<n;i++) {
								if(m[i][iter_item] !== 0) {
										for(j=0;j<=n;j++) {
												k = m[i-1][j];
												m[i-1][j] = m[i][j];
												m[i][j] = k;
										}
								} 
						}
					};
					//Обнуление верхнего треугольника
					function ObrIteration(iter_item) { //Функция итеррация
						for(iter_item=n-1;iter_item >= 1;iter_item--) { //Цикл выполнения итерраций
								for(i=iter_item-1; i>=0; i--) { //Выполнение операций со строками
										for(j=n;j>=iter_item;j--) {
												m[i][j] = m[i][j] - (m[iter_item][j] * m[i][iter_item])/m[iter_item][iter_item];
										}
								}
							
						}
					};
				//Вывод решения
				let x ="\\begin{cases}";
				for(i=0; i<n; i++) { //Выполнение операций со строками
					x1=m[i][n]/m[i][i]
						x+="x_{" + (i+1) +"}" + " = " + x1;
						x+="\\\\"
				}
				x+="\\end{cases}"
				document.querySelector('#_result1').innerHTML = katex.renderToString(x);
			}
		</script>

<!--
		<script>
			window.onload = () => {
				document.querySelector('#click').onclick = () => {
					//Скрываем саму кнопку
					document.querySelector('#_size').style.display = 'none';
					document.querySelector('#size').style.display = 'none';
					//Забираем значение из поле ввода
					let a11 = document.querySelector('#11').value;
					let a12 = document.querySelector('#21').value;
					let a13 = document.querySelector('#31').value;
					let a21 = document.querySelector('#21').value;
					let a22 = document.querySelector('#22').value;
					let a23 = document.querySelector('#23').value;
					let a31 = document.querySelector('#31').value;
					let a32 = document.querySelector('#32').value;
					let a33 = document.querySelector('#33').value;
					let b1 = document.querySelector('#1').value;
					let b2 = document.querySelector('#2').value;
					let b3 = document.querySelector('#3').value;
					
					//Ссылка на тег результата
					let result = document.querySelector('#otvet');
					result = 
					document.querySelector('#otvet').innerHTML = result;
				}
			}
				var m=new Array(3);
				var l=new Array(3);
				for(i=0; i<3; ++i) {
					m[i] = new Array(3);
					l[i] = new Array(3);
				}
				for(i=0; i<n; ++i) { //Заполнение матрицы
					for(j=0; j <= n; ++j) {
							m[i][j] = aij;
					}
				}

			window.onload = () => {
				document.querySelector('#_size').onclick = () => {
					//Скрываем саму кнопку
					document.querySelector('#_size').style.display = 'none';
					document.querySelector('#size').style.display = 'none';
					//Забираем значение из поле ввода
					let n = document.querySelector('#size').value;
					//Ссылка на тег результата
					let result = document.querySelector('#_result');
					//Делаем проверки на пустые поля
					if (n === '') {
						return result.innerHTML = 'Вы не ввели размерность матрицы';
					}


					document.querySelector('#_result').innerHTML = result;
				}
			}
				function matrix(size) {
					var m = [[]];
					for (var i = 0; i < size+1; i += 1) {
						m[i]=[];
						for (var j = 0; j < size; j += 1) {
							m[j]=document.createElement('number');
						}
					}
					return m;
				}
		</script>
		-->
	</body>
</html>